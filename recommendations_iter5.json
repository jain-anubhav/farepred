{
  "analysis": "The dominant unresolved problem is high-price-tier systematic underprediction (mean_residual=+37.47, RMSE=103.15), which the log-ratio transform made worse versus v4 because the model still reverts to the mean log-ratio even when a flight is priced near or above its historical maximum. The DFD x price cross-tab confirms this is not a DFD artifact: high-tier mean_residual is +12.89 even at DFD 0-9 and +26.78 at DFD 20-29, meaning the model structurally underpredicts high-priced flights at all booking horizons. Feature correlation analysis reveals that hist_price_max (corr=0.37), price_above_emf (corr=0.36), and price_at_obs (corr=0.35) are the features most associated with large residuals, pointing to the upper tail of the historical price distribution as an unexploited signal. Secondary patterns include persistent short-DFD underprediction (DFD 0-9 mean_residual=~10, RMSE=80+), evening-departure premium underestimation (19-24h mean_residual=+6.4), Thursday/Friday departure bias (DOW 3-4 mean_residual=+6.2/+6.1), and a critical model-utility problem where the baseline beats the ML model on 63.4% of observations — suggesting a stacked ensemble that uses the baseline more aggressively at mid-to-high prices would recover substantial value.",
  "recommendations": [
    {
      "priority": 1,
      "type": "feature_engineering",
      "title": "Historical Price Ceiling Proximity Ratio and Extreme-Tier Flags",
      "idea": "Compute three features anchored to the upper tail of the per-flight historical price distribution: (1) price_to_hist_max_ratio = price_at_obs / (hist_price_max + 1e-6) — how close is the current price to the historical ceiling; (2) price_to_hist_p90_ratio = price_at_obs / (hist_price_p90 + 1e-6) where hist_price_p90 is the 90th-percentile of historical prices for that flight; (3) hist_price_headroom = (hist_price_max - price_at_obs) / (hist_price_std + 1e-6) — how many standard deviations of room is left before the observed historical maximum. Also add a boolean is_above_hist_max = (price_at_obs > hist_price_max).astype(int) to flag true outlier-high events.",
      "rationale": "hist_price_max has the highest correlation with absolute residual (0.37) across all features, and price_at_obs/price_dfd40 correlate at 0.35. The current feature set has hist_price_max and hist_price_mean as raw values but no ratio of current price to historical ceiling. When price_at_obs approaches or exceeds hist_price_max, the log-ratio model still regresses toward the mean log-ratio — it cannot identify that this flight is operating in an extreme-price regime. price_to_hist_max_ratio directly encodes this ceiling proximity. The DFD x price cross-tab shows high-tier residuals of +26.78 at DFD 20-29, precisely where a flight priced near its historical max still has weeks for prices to consolidate at elevated levels before final sale.",
      "implementation_hint": "# Requires hist_price_p90 to be precomputed in the historical stats table (add alongside hist_price_max/mean)\n# If not yet available, approximate as: hist_price_p90 = hist_price_mean + 1.28 * hist_price_std\ndf['hist_price_p90_approx'] = df['hist_price_mean'] + 1.28 * df['hist_price_std']\ndf['price_to_hist_max_ratio'] = df['price_at_obs'] / (df['hist_price_max'] + 1e-6)\ndf['price_to_hist_p90_ratio'] = df['price_at_obs'] / (df['hist_price_p90_approx'] + 1e-6)\ndf['hist_price_headroom'] = (df['hist_price_max'] - df['price_at_obs']) / (df['hist_price_std'] + 1e-6)\ndf['is_above_hist_max'] = (df['price_at_obs'] > df['hist_price_max']).astype(int)\n# Also add squared version to capture non-linearity:\ndf['price_to_hist_max_ratio_sq'] = df['price_to_hist_max_ratio'] ** 2"
    },
    {
      "priority": 2,
      "type": "model_architecture",
      "title": "Stacked Ensemble: Blend ML Prediction with Baseline Using Price-Tier Confidence Weights",
      "idea": "Train a second-level meta-model (or use a simple weighted blend) that combines the LightGBM log-ratio prediction and the baseline prediction, where the blending weights are a function of price tier and DFD. Specifically: final_pred = w * lgbm_pred + (1 - w) * baseline_pred, where w is learned per (price_tier, dfd_bucket) stratum from out-of-fold residuals. For the high-price tier, the baseline may dominate (w close to 0) because the raw baseline already encodes market-level pricing information that the LightGBM is failing to improve upon. The meta-model can be as simple as an isotonic regression or ridge regression over [lgbm_pred, baseline_pred, lgbm_pred * price_tier_high_flag, lgbm_pred * dfd_frac].",
      "rationale": "The model beats the baseline on only 36.6% of observations (pct_ml_better=0.366), and the worst_ml_dfd_buckets shows the baseline outperforms in the 20-29 and 30-39 DFD buckets by a large margin (52k-60k observations). For the high-price tier specifically, the baseline's structural encoding of market fares likely anchors near actual prices better than the log-ratio prediction that regresses toward the mean. A stacked blend allows the model to defer to the baseline in regimes where it is consistently wrong, rather than applying a single global LightGBM prediction. This directly targets the mean_residual=+37.47 high-tier problem by allowing the baseline (which may have near-zero mean_residual for high-tier flights) to dominate.",
      "implementation_hint": "# 1. Generate out-of-fold LightGBM predictions during k-fold CV (k=5)\n# 2. For each OOF fold, compute: residual = actual - lgbm_pred; baseline_residual = actual - baseline_pred\n# 3. Train meta-model on OOF set:\nimport numpy as np\nfrom sklearn.linear_model import Ridge\nX_meta = np.column_stack([\n    oof_lgbm_pred,\n    oof_baseline_pred,\n    oof_lgbm_pred * (price_tier == 'high').astype(float),\n    oof_lgbm_pred * dfd_frac,\n    oof_baseline_pred * (price_tier == 'high').astype(float)\n])\ny_meta = actual_prices\nmeta_model = Ridge(alpha=1.0).fit(X_meta, y_meta)\n# At inference:\nX_test_meta = np.column_stack([lgbm_pred_test, baseline_pred_test, ...])\nfinal_pred = meta_model.predict(X_test_meta)\n# Alternative: simple per-stratum blend\nfor tier in ['low', 'med-low', 'med-high', 'high']:\n    mask = price_tier_oof == tier\n    w = np.clip(1 - (oof_residual[mask].mean() / oof_baseline_residual[mask].mean()), 0, 1)\n    blend_weights[tier] = w"
    },
    {
      "priority": 3,
      "type": "feature_engineering",
      "title": "DFD-Weighted Price Premium Amplification Score",
      "idea": "Create an interaction feature that captures how the current price premium above EMF is amplified by proximity to departure: (1) dfd_price_premium_interaction = (price_above_emf / (emf_at_obs + 1e-6)) * (1 / (dfd_frac + 0.05)) — the fractional price premium scaled inversely by DFD fraction, so that a 20% premium at DFD=5 has much higher weight than the same premium at DFD=35; (2) log_premium_x_inv_dfd = log1p(price_above_emf.clip(0)) * log1p(1 / (dfd + 1)) — log-scaled version that is more robust to outliers; (3) price_above_hist_mean_x_inv_dfd = (price_at_obs - hist_price_mean) / (hist_price_std + 1e-6) * (40 - dfd) — a DFD-weighted z-score that increases as departure approaches and price stays elevated.",
      "rationale": "The DFD x price cross-table shows that high-tier mean_residual is worst at DFD 20-29 (+26.78) and DFD 10-19 (+21.85) but somewhat better at DFD 0-9 (+12.89). This non-monotonic pattern suggests that the model is failing to capture a specific dynamic: flights that are expensive 2-4 weeks out tend to end up even more expensive at departure, while flights that are only expensive in the last few days are closer to their final price. The interaction between current price premium and DFD directly encodes this booking-curve amplification. price_above_emf (corr=0.36 with abs residual) and dfd (corr=-0.15) are already important features but their product is not in the feature set.",
      "implementation_hint": "df['price_premium_frac'] = df['price_above_emf'].clip(lower=0) / (df['emf_at_obs'] + 1e-6)\ndf['dfd_price_premium_interaction'] = df['price_premium_frac'] / (df['dfd_frac'] + 0.05)\n# Log-scaled version for robustness:\nimport numpy as np\ndf['log_premium_x_inv_dfd'] = (\n    np.log1p(df['price_above_emf'].clip(lower=0)) *\n    np.log1p(1.0 / (df['dfd'] + 1))\n)\n# DFD-weighted z-score (captures 'price has been high for a long time'):\ndf['price_zscore_x_dfd_remaining'] = (\n    (df['price_at_obs'] - df['hist_price_mean']) / (df['hist_price_std'] + 1e-6)\n) * (40 - df['dfd']).clip(lower=0)\n# Clip extremes to prevent outlier blowup:\ndf['dfd_price_premium_interaction'] = df['dfd_price_premium_interaction'].clip(-10, 50)"
    },
    {
      "priority": 4,
      "type": "feature_engineering",
      "title": "Departure Time Premium Encoding: Evening + Weekend Departure Interaction",
      "idea": "Construct structured departure-premium features: (1) is_evening_departure = (dephour >= 17).astype(int) — evening departures (17:00+) command a premium not fully captured by the raw dephour continuous feature; (2) is_peak_dow = depdow.isin([3, 4]).astype(int) for Thursday/Friday departures; (3) evening_x_peak_dow = is_evening_departure * is_peak_dow — captures the highest-premium segment (Thursday/Friday evening flights); (4) dephour_sin = sin(2 * pi * dephour / 24) and dephour_cos = cos(2 * pi * dephour / 24) — cyclical encoding so the model understands 23:00 and 01:00 are adjacent; (5) depdow_sin = sin(2 * pi * depdow / 7) and depdow_cos = cos(2 * pi * depdow / 7) — analogous cyclical encoding for day of week.",
      "rationale": "The by_depdow analysis shows DOW=0 (Monday) RMSE=69.8 and DOW=3,4 (Thu/Fri) mean_residual=+6.2/+6.1. The by_dephour analysis shows 19-24h bucket mean_residual=+6.4 and RMSE=62.3 versus only 0.01 for 0-6h. Both dephour and depdow are currently encoded as raw integers, which forces the model to learn discontinuous non-linear relationships (e.g., dephour=23 and dephour=0 are numerically distant but cyclically adjacent). Cyclical sin/cos encoding and explicit binary peak flags give the model cleaner signals about the Thursday-evening premium that is systematically underpredicted. The interaction evening_x_peak_dow directly targets the highest-residual departure segment without requiring the model to discover the interaction from raw integer features.",
      "implementation_hint": "import numpy as np\n# Binary peak flags:\ndf['is_evening_departure'] = (df['dephour'] >= 17).astype(int)\ndf['is_peak_dow'] = df['depdow'].isin([3, 4]).astype(int)\ndf['is_monday'] = (df['depdow'] == 0).astype(int)\ndf['evening_x_peak_dow'] = df['is_evening_departure'] * df['is_peak_dow']\n# Cyclical encoding for dephour (24-hour cycle):\ndf['dephour_sin'] = np.sin(2 * np.pi * df['dephour'] / 24)\ndf['dephour_cos'] = np.cos(2 * np.pi * df['dephour'] / 24)\n# Cyclical encoding for depdow (7-day cycle):\ndf['depdow_sin'] = np.sin(2 * np.pi * df['depdow'] / 7)\ndf['depdow_cos'] = np.cos(2 * np.pi * df['depdow'] / 7)\n# Premium interaction: high-tier price x evening x peak_dow\ndf['high_price_evening_peak'] = (\n    (df['price_at_obs'] > df['hist_price_mean']).astype(int) *\n    df['is_evening_departure'] * df['is_peak_dow']\n)"
    }
  ]
}
