{
  "analysis": "The dominant residual pattern is a strong price-tier bias: the model systematically over-predicts low fares (mean_residual = -16.8 for 'low' tier, RMSE = 29) and severely under-predicts high fares (mean_residual = +28.4 for 'high' tier, RMSE = 101.3), indicating the model treats price levels as an additive offset when the true relationship with future fare is multiplicative or regime-dependent. This bias is amplified at short DFD: the DFD 0-9 / low-price cell has mean_residual = -39.96 and DFD 10-19 / high-price has mean_residual = +15.2, suggesting different booking dynamics that a single model fails to capture. There is also large, systematic market-level bias (market 2 mean_residual = -16.1, market 9 = +8.2, market RMSE spread std = 20.4) that persists after controlling for trajectory features, implying market-specific fare elasticity or competitive structure is not encoded. The 2-airline duopoly slice has mean_residual = -13.7 versus -1.1 for 3-airline markets, strongly suggesting competitive-structure features are missing. Finally, the model underperforms the baseline on 64.6% of observations and actually loses to the pass-through baseline at DFD=39, pointing to a near-observation overfitting problem where the baseline already captures the signal better.",

  "recommendations": [
    {
      "priority": 1,
      "type": "feature_engineering",
      "title": "Price-Level Percentile Rank Within Market-DFD Distribution",
      "idea": "For each row, compute the percentile rank of price_at_obs within the empirical distribution of prices for the same (pathod_id, dfd_bucket) combination, using historical training data. Specifically, compute: (1) the in-sample CDF of price_at_obs grouped by (pathod_id, dfd_bucket) and store as a lookup table; (2) at inference time, map each price to its percentile rank (0-1). Also compute the absolute z-score: (price_at_obs - group_mean) / group_std. Add both as features: price_pctrank_market_dfd and price_zscore_market_dfd.",
      "rationale": "The price-tier analysis shows RMSE of 101.3 and mean_residual of +28.4 for the 'high' tier versus RMSE of 29.1 and mean_residual of -16.8 for the 'low' tier. The current features (price_to_emf, price_to_market_min) give relative price but do not tell the model where a given price sits in the full empirical distribution for that market at that DFD. A percentile rank directly encodes whether this is an outlier high/low price event, which the model currently cannot distinguish from a normally-priced flight in a high-price market.",
      "implementation_hint": "import numpy as np\n# During training:\ndf['dfd_bucket'] = pd.cut(df['dfd'], bins=[0,9,19,29,39], labels=['0-9','10-19','20-29','30-39'])\ngroup_stats = df.groupby(['pathod_id','dfd_bucket'])['price_at_obs'].agg(['mean','std']).reset_index()\ndf = df.merge(group_stats, on=['pathod_id','dfd_bucket'], suffixes=('','_grp'))\ndf['price_zscore_market_dfd'] = (df['price_at_obs'] - df['mean']) / (df['std'] + 1e-6)\n# For percentile rank, use transform:\ndf['price_pctrank_market_dfd'] = df.groupby(['pathod_id','dfd_bucket'])['price_at_obs'].transform(lambda x: x.rank(pct=True))\n# At inference, use the stored group_stats lookup to z-score new rows."
    },
    {
      "priority": 2,
      "type": "feature_engineering",
      "title": "Market-Specific Residual Bias Correction Encoding (Market Fare Elasticity Proxy)",
      "idea": "Compute three market-level features from historical data: (1) market_price_cv = std(price) / mean(price) within each pathod_id across all DFDs, capturing how volatile fares are in this market; (2) market_dfd_slope = OLS slope of median_price ~ dfd for each pathod_id (steeper = fares rise faster near departure); (3) market_high_price_pct = fraction of observations where price > 1.5 * market median for each pathod_id. Join these to the main dataframe on pathod_id.",
      "rationale": "Market RMSE ranges from 39 to 104 with a std of 20.4 across only 10 markets, and individual markets show large directional biases (market 2 mean_residual = -16.1, market 6 = -12.3, market 7 = -8.6, market 9 = +8.2). The current feature set uses pathod_id as a raw categorical but does not encode any structural property of the market. These three features give the model interpretable signals about fare elasticity and price dispersion by market without simply overfitting pathod_id as an ID.",
      "implementation_hint": "# Compute on training data, then join to train and test:\nmarket_cv = df.groupby('pathod_id')['price_at_obs'].agg(lambda x: x.std() / (x.mean() + 1e-6)).rename('market_price_cv')\nmarket_slope = df.groupby(['pathod_id','dfd'])['price_at_obs'].median().reset_index()\ndef calc_slope(g):\n    x = g['dfd'].values; y = g['price_at_obs'].values\n    return np.polyfit(x, y, 1)[0]\nmarket_dfd_slope = market_slope.groupby('pathod_id').apply(calc_slope).rename('market_dfd_slope')\nmarket_high_pct = df.groupby('pathod_id').apply(lambda g: (g['price_at_obs'] > 1.5 * g['price_at_obs'].median()).mean()).rename('market_high_price_pct')\ndf = df.join(market_cv, on='pathod_id').join(market_dfd_slope, on='pathod_id').join(market_high_pct, on='pathod_id')"
    },
    {
      "priority": 3,
      "type": "feature_engineering",
      "title": "Competitive Pressure Score: Duopoly Flag and Price Spread Between Airlines",
      "idea": "Compute: (1) is_duopoly = (market_n_airlines == 2).astype(int); (2) airline_price_spread = market_max_price - market_min_price (already available as individual features, compute the spread explicitly); (3) price_vs_market_spread_pct = (price_at_obs - market_min_price) / (market_max_price - market_min_price + 1e-6), capturing where this flight sits in the within-market spread on the offer date; (4) airline_relative_price_rank = price_at_obs / market_mean_price, normalized competitive position.",
      "rationale": "The by_n_airlines slice shows duopoly markets (2 airlines) have mean_residual = -13.73 versus -1.09 for 3-airline markets, with RMSE 51.7 versus 59.2. Duopoly markets behave differently: less competitive pressure means prices are more likely to stay elevated or drop in non-standard patterns. Feature market_n_airlines already exists but the is_duopoly binary and the relative competitive position features allow the model to specifically characterize the fare dynamics in these structurally different markets.",
      "implementation_hint": "df['is_duopoly'] = (df['market_n_airlines'] == 2).astype(int)\ndf['airline_price_spread'] = df['market_max_price'] - df['market_min_price']\ndf['price_vs_market_spread_pct'] = (\n    (df['price_at_obs'] - df['market_min_price']) /\n    (df['airline_price_spread'] + 1e-6)\n).clip(0, 1)\ndf['airline_relative_price_rank'] = df['price_at_obs'] / (df['market_mean_price'] + 1e-6)\n# is_duopoly can be used as an interaction with dfd for split-model or as a feature directly"
    },
    {
      "priority": 4,
      "type": "feature_engineering",
      "title": "DFD-Conditional Trajectory Deviation: Distance from Historical Trajectory at Current DFD",
      "idea": "The model already has hist_traj_mean, hist_traj_std, and price_vs_hist_traj. Add the following: (1) traj_deviation_normalized = (price_at_obs - hist_traj_mean_at_obs) / (hist_traj_std_at_obs + 1e-6) — a per-DFD z-score against the historical trajectory; (2) traj_momentum = price_vs_hist_traj - hist_traj_ratio_at_obs, i.e., how much the current price-to-trajectory ratio has changed since DFD=40; (3) traj_percentile_at_obs = rank of price_at_obs against the distribution implied by (hist_traj_mean_at_obs, hist_traj_std_at_obs) using the normal CDF approximation: scipy.stats.norm.cdf(price_at_obs, loc=hist_traj_mean_at_obs, scale=hist_traj_std_at_obs + 1e-6).",
      "rationale": "hist_traj_std is the second-most important feature (importance 12214) and hist_traj_mean is 4th (7730), confirming trajectory signals are valuable. However, price_vs_hist_traj (importance 3904) and hist_traj_ratio_at_obs are lower, suggesting the model is not efficiently using the combination of 'current DFD deviation from trajectory' in a normalized form. The DFD x price interaction table shows that high-price + any DFD cells have the largest positive residuals (+15 to +20), which corresponds to cases where the price is far above the expected trajectory — exactly what traj_deviation_normalized captures.",
      "implementation_hint": "# hist_traj_mean_at_obs, hist_traj_std_at_obs should already be computed per (flight, dfd)\ndf['traj_deviation_normalized'] = (\n    (df['price_at_obs'] - df['hist_traj_mean_at_obs']) /\n    (df['hist_traj_std_at_obs'] + 1e-6)\n)\ndf['traj_momentum'] = df['price_vs_hist_traj'] - df['hist_traj_ratio_at_obs']\nfrom scipy.stats import norm\ndf['traj_percentile_at_obs'] = norm.cdf(\n    df['price_at_obs'],\n    loc=df['hist_traj_mean_at_obs'],\n    scale=(df['hist_traj_std_at_obs'] + 1e-6)\n)"
    },
    {
      "priority": 5,
      "type": "feature_engineering",
      "title": "Offer-Date Seasonal Momentum: Days to Peak Season and Within-Season Trend",
      "idea": "Compute: (1) dep_dayofyear = day-of-year of the departure date (inferred as offer_date + dfd); (2) days_to_peak_summer = abs(dep_dayofyear - 196) (day 196 = July 15, approximate US summer peak); (3) days_to_peak_holiday = min(abs(dep_dayofyear - 355), abs(dep_dayofyear - 1)) for Thanksgiving/Christmas window; (4) is_peak_season = 1 if dep_dayofyear in [170,240] or [340,365] else 0; (5) offer_date_vs_dep_season = interaction of offer_month with is_peak_season (are you booking peak travel during peak booking season?).",
      "rationale": "The by_offer_month slice shows systematic directional bias: January (mean_residual = -8.39) vs April (mean_residual = +4.99). The offer_dayofyear feature already has importance of 6565, but it encodes the booking date, not the departure seasonality. Flights booked in January for summer travel (peak season) behave very differently from January bookings for February travel. Departure seasonality relative to booking date is a missing interaction. The model currently cannot distinguish 'January booking for a July flight' from 'January booking for a February flight.'",
      "implementation_hint": "# Reconstruct dep_dayofyear from offer date and dfd\nimport pandas as pd\ndf['dep_date'] = pd.to_datetime(df['offer_date']) + pd.to_timedelta(df['dfd'], unit='D')\ndf['dep_dayofyear'] = df['dep_date'].dt.dayofyear\ndf['days_to_peak_summer'] = (df['dep_dayofyear'] - 196).abs()\ndf['days_to_peak_holiday'] = df['dep_dayofyear'].apply(\n    lambda d: min(abs(d - 355), abs(d - 1))\n)\ndf['is_peak_departure'] = df['dep_dayofyear'].apply(\n    lambda d: 1 if (170 <= d <= 240) or (340 <= d <= 365) else 0\n)\ndf['peak_booking_x_peak_dep'] = df['offer_month'].isin([6,7,8,12]).astype(int) * df['is_peak_departure']"
    }
  ]
}
